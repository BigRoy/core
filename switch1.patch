From cd389af132e03afaedff6161752b418785c3d7b6 Mon Sep 17 00:00:00 2001
From: Roy Nieterau <roy_nieterau@hotmail.com>
Date: Wed, 14 Mar 2018 13:08:15 +0100
Subject: [PATCH] Refactor search combobox to its own class

- Also fix "tab" cycle focus from left to right.
- Also sort the names in the combobox
---
 avalon/tools/cbsceneinventory/app.py | 128 +++++++++++++++++------------------
 1 file changed, 63 insertions(+), 65 deletions(-)

diff --git a/avalon/tools/cbsceneinventory/app.py b/avalon/tools/cbsceneinventory/app.py
index 3fd2395..0f06b45 100644
--- a/avalon/tools/cbsceneinventory/app.py
+++ b/avalon/tools/cbsceneinventory/app.py
@@ -242,6 +242,48 @@ class View(QtWidgets.QTreeView):
         self.data_changed.emit()
 
 
+class SearchComboBox(QtWidgets.QComboBox):
+    """Searchable ComboBox with empty placeholder value as first value"""
+
+    def __init__(self, parent=None, placeholder=""):
+        super(SearchComboBox, self).__init__(parent)
+
+        self.setEditable(True)
+        self.setInsertPolicy(self.NoInsert)
+        self.lineEdit().setPlaceholderText(placeholder)
+
+        # Apply completer settings
+        completer = self.completer()
+        completer.setCompletionMode(completer.PopupCompletion)
+        completer.setCaseSensitivity(QtCore.Qt.CaseInsensitive)
+
+        # Force style sheet on popup menu
+        # It won't take the parent stylesheet for some reason
+        # todo: better fix for completer popup stylesheet
+        if module.window:
+            popup = completer.popup()
+            popup.setStyleSheet(module.window.styleSheet())
+
+    def populate(self, items):
+        self.clear()
+        self.addItems([""])     # ensure first item is placeholder
+        self.addItems(items)
+
+    def get_valid_value(self):
+        """Return the current text if it's a valid value else None
+
+        Note: The empty placeholder value is valid and returns as ""
+
+        """
+
+        text = self.currentText()
+        lookup = set(self.itemText(i) for i in range(self.count()))
+        if text not in lookup:
+            return None
+
+        return text
+
+
 class SwitchAssetDialog(QtWidgets.QDialog):
     """Widget to support asset switching"""
 
@@ -256,12 +298,12 @@ class SwitchAssetDialog(QtWidgets.QDialog):
 
         self._items = items
 
-        self._assets_box = None
-        self._subsets_box = None
-        self._representations_box = None
+        self._assets_box = SearchComboBox(placeholder="<asset>")
+        self._subsets_box = SearchComboBox(placeholder="<subset>")
+        self._representations_box = SearchComboBox(
+            placeholder="<representation>")
 
         input_layout = QtWidgets.QHBoxLayout()
-        input_layout.setDirection(QtWidgets.QBoxLayout.RightToLeft)
 
         accept_icon = qta.icon("fa.check", color="white")
         accept_btn = QtWidgets.QPushButton()
@@ -269,6 +311,9 @@ class SwitchAssetDialog(QtWidgets.QDialog):
         accept_btn.setFixedWidth(24)
         accept_btn.setFixedHeight(24)
 
+        input_layout.addWidget(self._assets_box)
+        input_layout.addWidget(self._subsets_box)
+        input_layout.addWidget(self._representations_box)
         input_layout.addWidget(accept_btn)
 
         self._input_layout = input_layout
@@ -279,65 +324,28 @@ class SwitchAssetDialog(QtWidgets.QDialog):
 
         self.connections()
 
-        self.build_comboboxes()
+        self.refresh()
 
         self.setFixedSize(self.sizeHint())  # Lock window size
 
-        self._assets_box.setFocus()  # Ensure the accept button is not focused
+        # Set default focus to accept button so you don't directly type in
+        # first asset field, this also allows to see the placeholder value.
+        accept_btn.setFocus()
 
     def connections(self):
         self._accept_btn.clicked.connect(self._on_accept)
 
-    def build_comboboxes(self):
+    def refresh(self):
         """Build the need comboboxes with content"""
 
-        assets = self._get_assets()
-        self._assets_box = self._create_combo_box(
-            assets, initial_item="<assets>")
-
-        subsets = self._get_subsets()
-        self._subsets_box = self._create_combo_box(
-            subsets, initial_item="<subsets>")
+        assets = sorted(self._get_assets())
+        self._assets_box.populate(assets)
 
-        representations = self._get_representations()
-        self._representations_box = self._create_combo_box(
-            representations, initial_item="<representations>")
+        subsets = sorted(self._get_subsets())
+        self._subsets_box.populate(subsets)
 
-        self._input_layout.addWidget(self._representations_box)
-        self._input_layout.addWidget(self._subsets_box)
-        self._input_layout.addWidget(self._assets_box)
-
-    def _create_combo_box(self, items, initial_item):
-        """Create a combobox with auto completion, first item will be "----"
-
-        Args:
-            items (iterable): list of document names
-            initial_item (str): name of the initial item
-
-        Returns:
-            QtWidgets.QComboBox
-
-        """
-
-        combobox = QtWidgets.QComboBox()
-        combobox.setEditable(True)
-        combobox.setInsertPolicy(combobox.NoInsert)
-
-        # Apply completer settings
-        completer = combobox.completer()
-        completer.setCompletionMode(completer.PopupCompletion)
-        completer.setCaseSensitivity(QtCore.Qt.CaseInsensitive)
-
-        # Force style sheet on popup menu
-        # It won't take the parent stylesheet for some reason
-        if module.window:
-            popup = completer.popup()
-            popup.setStyleSheet(module.window.styleSheet())
-
-        items.insert(0, initial_item)
-        combobox.addItems(items)
-
-        return combobox
+        representations = sorted(self._get_representations())
+        self._representations_box.populate(representations)
 
     def _get_assets(self):
         return self._get_document_names("asset")
@@ -356,21 +364,11 @@ class SwitchAssetDialog(QtWidgets.QDialog):
 
         return io.find(query).distinct("name")
 
-    def _validate_combo_box_value(self, combo_box):
-
-        current_text = combo_box.currentText()
-        items = [combo_box.itemText(i) for i in range(combo_box.count())]
-        if current_text not in items:
-            return None
-
-        return current_text
-
     def _on_accept(self):
 
-        asset = self._validate_combo_box_value(self._assets_box)
-        subset = self._validate_combo_box_value(self._subsets_box)
-        representation = self._validate_combo_box_value(
-            self._representations_box)
+        asset = self._assets_box.get_valid_value()
+        subset = self._subsets_box.get_valid_value()
+        representation = self._representations_box.get_valid_value()
 
         if not any([asset, subset, representation]):
             self.log.error("Nothing selected")
-- 
2.16.2.windows.1

