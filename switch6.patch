From 4b55e778b3a95c781634ea5bc4e517c808bd9f36 Mon Sep 17 00:00:00 2001
From: wijnand <wikoreman@gmail.com>
Date: Tue, 13 Mar 2018 16:42:18 +0100
Subject: [PATCH] Improved UI, locks ui, improved query call, moved switch_item

---
 avalon/tools/cbsceneinventory/app.py | 121 +++++++++--------------------------
 1 file changed, 30 insertions(+), 91 deletions(-)

diff --git a/avalon/tools/cbsceneinventory/app.py b/avalon/tools/cbsceneinventory/app.py
index 6be95af..106e013 100644
--- a/avalon/tools/cbsceneinventory/app.py
+++ b/avalon/tools/cbsceneinventory/app.py
@@ -17,6 +17,8 @@ from ..cbloader.lib import refresh_family_config
 from .proxy import FilterProxyModel
 from .model import InventoryModel
 
+from .lib import switch_item
+
 DEFAULT_COLOR = "#fb9c15"
 
 module = sys.modules[__name__]
@@ -272,31 +274,37 @@ class SwitchAssetDialog(QtWidgets.QDialog):
 
         self.connections()
 
-        self.refresh()
+        self.build_comboboxes()
+        # Lock window size
+        self.setFixedSize(self.sizeHint())
 
     def connections(self):
         self._accept_btn.clicked.connect(self._on_accept)
 
-    def refresh(self):
+    def build_comboboxes(self):
 
         assets = self._get_assets()
-        self._assets_box = self._create_combo_box(assets)
+        self._assets_box = self._create_combo_box(
+            assets, initial_item="assets")
 
         subsets = self._get_subsets()
-        self._subsets_box = self._create_combo_box(subsets)
+        self._subsets_box = self._create_combo_box(
+            subsets, initial_item="subsets")
 
         representations = self._get_representations()
-        self._representations_box = self._create_combo_box(representations)
+        self._representations_box = self._create_combo_box(
+            representations, initial_item="representations")
 
         self._input_layout.addWidget(self._representations_box)
         self._input_layout.addWidget(self._subsets_box)
         self._input_layout.addWidget(self._assets_box)
 
-    def _create_combo_box(self, items):
+    def _create_combo_box(self, items, initial_item=None):
         """Create a combobox with auto completion, first item will be "----"
 
         Args:
             items (iterable): list of document names
+            initial_item (str, optional): name of the initial item
 
         Returns:
             QtWidgets.QComboBox
@@ -305,32 +313,32 @@ class SwitchAssetDialog(QtWidgets.QDialog):
 
         combobox = QtWidgets.QComboBox()
         completer = QtWidgets.QCompleter(items)
+
+        combobox.setInsertPolicy(QtWidgets.QComboBox.NoInsert)
         combobox.setCompleter(completer)
         combobox.setEditable(True)
-        combobox.addItem("----")
+
+        combobox.addItem(initial_item or "----")
         combobox.addItems(items)
 
         return combobox
 
     def _get_assets(self):
-        return self._get_documents_by_name("asset")
+        return self._get_document_names("asset")
 
     def _get_subsets(self):
-        return self._get_documents_by_name("subset")
+        return self._get_document_names("subset")
 
     def _get_representations(self):
-        return self._get_documents_by_name("representation")
+        return self._get_document_names("representation")
 
-    def _get_documents_by_name(self, document_type, parent=None):
+    def _get_document_names(self, document_type, parent=None):
 
         query = {"type": document_type}
         if parent:
             query["parent"] = parent["_id"]
 
-        documents = io.find(query)
-        documents_by_name = set([s["name"] for s in documents])
-
-        return sorted(list(documents_by_name))
+        return io.find(query).distinct("name")
 
     def _get_combo_box_value(self, combo_box):
 
@@ -350,87 +358,18 @@ class SwitchAssetDialog(QtWidgets.QDialog):
             return None
 
         for item in self._items:
-            self.switch_item(item,
-                             asset_name=asset,
-                             subset_name=subset,
-                             representation_name=representation)
+            try:
+                switch_item(item,
+                            asset_name=asset,
+                            subset_name=subset,
+                            representation_name=representation)
+            except Exception as e:
+                print(e)
 
         self.switched.emit()
 
         self.close()
 
-    def switch_item(self,
-                    container,
-                    asset_name=None,
-                    subset_name=None,
-                    representation_name=None):
-        """Switch container asset, subset or representation of a container by name.
-
-        It'll always switch to the latest version - of course a different
-        approach could be implemented.
-
-        Args:
-            container (dict): data of the item to switch with
-            asset_name (str): name of the asset
-            subset_name (str): name of the subset
-            representation_name (str): name of the representation
-
-        Returns:
-            dict
-
-        """
-
-        if all(not x for x in [asset_name, subset_name, representation_name]):
-            raise ValueError(
-                "Must have at least one change provided to switch.")
-
-        # Collect any of current asset, subset and representation if not provided
-        # so we can use the original name from those.
-        if any(not x for x in [asset_name, subset_name, representation_name]):
-            _id = io.ObjectId(container["representation"])
-            representation = io.find_one({"type": "representation", "_id": _id})
-            version, subset, asset, project = io.parenthood(representation)
-
-            if asset_name is None:
-                asset_name = asset["name"]
-
-            if subset_name is None:
-                subset_name = subset["name"]
-
-            if representation_name is None:
-                representation_name = representation["name"]
-
-        # Find the new one
-        asset = io.find_one({"name": asset_name, "type": "asset"})
-        assert asset, ("Could not find asset in the database with the name "
-                       "'%s'" % asset_name)
-
-        subset = io.find_one({"name": subset_name,
-                              "type": "subset",
-                              "parent": asset["_id"]})
-        assert subset, ("Could not find subset in the database with the name "
-                        "'%s'" % subset_name)
-
-        version = io.find_one({"type": "version",
-                               "parent": subset["_id"]},
-                              sort=[('name', -1)])
-
-        assert version, "Could not find a version for {}.{}".format(
-            asset_name, subset_name
-        )
-
-        representation = io.find_one({"name": representation_name,
-                                      "type": "representation",
-                                      "parent": version["_id"]})
-
-        assert representation, (
-                    "Could not find representation in the database with"
-                    " the name '%s'" % representation_name)
-
-        api.switch(container, representation)
-
-        return representation
-
 
 class Window(QtWidgets.QDialog):
     """Scene Inventory window"""
-- 
2.16.2.windows.1

